#!/usr/bin/env vpython
# coding=utf-8
# Copyright 2018 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

import datetime
import logging
import os
import random
import sys
import unittest
import json
import cgi
import mock
import base64
from parameterized import parameterized

import test_env_handlers

import webapp2
import webtest

from test_support import test_case

from components.prpc import encoding
from components import auth

import proto.api_v2.swarming_pb2 as swarming_pb2

from server import bot_management
from server import acl
from server import service_accounts

import handlers_bot
import handlers_prpc
import message_conversion_prpc

import google.protobuf as proto


# 2010-01-02T03:04:05Z
def fmtdate(d, fmt='%Y-%m-%dT%H:%M:%SZ'):
  """Formats a datetime.datetime instance to the format generated by the API.
  API datetime responses return at UTC+0 hence the Z at the end."""
  return unicode(d.strftime(fmt))


def _decode(raw, dst):
  assert raw[:5] == ')]}\'\n', raw[:5]
  return encoding.get_decoder(encoding.Encoding.JSON)(raw[5:], dst)


def _decode_dict(dct, out):
  return proto.json_format.ParseDict(dct, out)


def _encode(d):
  raw = encoding.get_encoder(encoding.Encoding.JSON)(d)
  assert raw[:5] == ')]}\'\n', raw[:5]
  return raw[5:]


def _bot_event(event_type, bot_id, **kwargs):
  args = {
      'authenticated_as': 'bot:whitelisted-ip',
      'dimensions': {
          u'id': [bot_id],
          u'pool': [u'default']
      },
      'external_ip': '8.8.4.4',
      'state': {
          'ram': 65
      },
      'version': '123456789',
      'quarantined': False,
      'maintenance_msg': None,
      'task_id': None,
      'task_name': None,
      'register_dimensions': event_type.startswith('request_')
  }
  args.update(kwargs)
  return bot_management.bot_event(event_type, bot_id, **args)


def apply_default_for_task_props(props):
  props.cipd_input.client_package.package_name = 'infra/tools/cipd/${platform}'
  props.cipd_input.client_package.version = 'git_revision:deadbeef'
  props.cipd_input.packages.extend([
      swarming_pb2.CipdPackage(package_name='rm',
                               path='bin',
                               version='git_revision:deadbeef')
  ])
  props.cipd_input.server = 'https://pool.config.cipd.example.com'
  props.command[:] = ['python', '-c', 'print(1)']
  props.containment.containment_type = swarming_pb2.ContainmentType.AUTO
  props.dimensions.extend([
      swarming_pb2.StringPair(key='os', value='Amiga'),
      swarming_pb2.StringPair(key='pool', value='default')
  ])
  props.execution_timeout_secs = 3600
  props.grace_period_secs = 30
  props.idempotent = False
  props.io_timeout_secs = 1200
  props.outputs[:] = ['foo', 'path/to/foobar']


def apply_defaults_for_request(request):
  """Applies some default expectations to a TaskRequestResponse

  To be used for expectations.
  """
  # This assumes:
  # self.mock(random, 'getrandbits', lambda _: 0x88)
  request.authenticated = 'user:user@example.com'
  request.expiration_secs = 86400
  request.task_id = '5cee488008810'
  request.name = 'job1'
  request.priority = 20
  request.service_account = 'none'
  request.tags[:] = [
      u'a:tag',
      u'authenticated:user:user@example.com',
      u'os:Amiga',
      u'pool:default',
      u'priority:20',
      u'realm:none',
      u'service_account:none',
      u'swarming.pool.template:none',
      u'swarming.pool.version:pools_cfg_rev',
      u'user:joe@localhost',
  ]
  request.user = 'joe@localhost'
  request.bot_ping_tolerance_secs = 600


class PrpcTest(test_env_handlers.AppTestBase):
  no_run = 1
  service = None

  def apply_defaults_for_result_summary(self, result):
    """Applies default expectations to a TaskResultResponse initialized from a
    TaskResultSummary ndb entity.

    To be used for expectations.
    """
    # This assumes:
    # self.mock(random, 'getrandbits', lambda _: 0x88)
    del result.bot_dimensions[:]
    result.bot_dimensions.extend([
        swarming_pb2.StringListPair(key='id', value=['bot1']),
        swarming_pb2.StringListPair(key='os', value=['Amiga']),
        swarming_pb2.StringListPair(key='pool', value=['default'])
    ])
    result.bot_id = 'bot1'
    result.bot_version = self.bot_version
    result.current_task_slice = 0
    result.failure = False
    result.internal_failure = False
    result.name = 'job1'
    result.run_id = '5cee488008811'
    result.server_versions[:] = [u'v1a']
    result.state = swarming_pb2.TaskState.COMPLETED
    result.tags[:] = [
        'a:tag',
        'os:Amiga',
        'pool:default',
        'priority:20',
        'realm:none',
        'service_account:none',
        'swarming.pool.template:no_config',
        'user:joe@localhost',
    ]
    result.task_id = '5cee488008810'
    result.user = 'joe@localhost'

  def apply_defaults_for_run_result(self, result):
    """Returns a serialized swarming_rpcs.TaskResult initialized from a
    TaskRunResult.

    To be used for expectations.
    """
    result.bot_dimensions.extend([
        swarming_pb2.StringListPair(key='id', value=['bot1']),
        swarming_pb2.StringListPair(key='os', value=['Amiga']),
        swarming_pb2.StringListPair(key='pool', value=['default'])
    ])
    result.bot_id = 'bot1'
    result.bot_version = self.bot_version
    result.costs_usd.extend([0.0])
    result.current_task_slice = 0
    result.failure = False
    result.internal_failure = False
    result.name = 'job1'
    result.run_id = '5cee488008811'
    result.server_versions.extend(['v1a'])
    result.state = swarming_pb2.TaskState.RUNNING
    result.task_id = '5cee488008811'
    return result

  def gen_perf_stats_prpc(self, stats):
    """Returns a serialized swarming_rpcs.PerformanceStats.

    To be used for expectations.
    """
    stats.bot_overhead = 0.1
    stats.cache_trim.duration = 0.1
    stats.isolated_download.duration = 1.0
    stats.isolated_download.initial_size = 100000
    stats.isolated_download.initial_number_items = 10
    stats.isolated_download.items_cold = b'x\234\023\001\000\000\025\000\025'
    stats.isolated_download.items_hot = b'x\234\223\343\002\000\000H\000)'
    stats.isolated_download.num_items_cold = 1
    stats.isolated_download.total_bytes_items_cold = 20
    stats.isolated_download.num_items_hot = 2
    stats.isolated_download.total_bytes_items_hot = 70

    stats.isolated_upload.duration = 2.0
    stats.isolated_upload.items_cold = b'x\234cdT\003\000\000.\000)'
    stats.isolated_upload.items_hot = b'x\234cdd\324\007\000\000<\0003'
    stats.isolated_upload.num_items_cold = 3
    stats.isolated_upload.total_bytes_items_cold = 43
    stats.isolated_upload.num_items_hot = 4
    stats.isolated_upload.total_bytes_items_hot = 56

    stats.cleanup.duration = 0.1
    stats.package_installation.duration = 3.0
    stats.named_caches_install.duration = 0.1
    stats.named_caches_uninstall.duration = 0.1

  def post_prpc(self, rpc, request, expect_errors=False):
    assert self.service, "Child classes must define service"

    return self.app.post('/prpc/%s/%s' % (self.service, rpc),
                         _encode(request),
                         self._headers,
                         expect_errors=expect_errors)


class BotServicePrpcTest(PrpcTest):
  """Tests the pRPC handlers."""
  def setUp(self):
    super(BotServicePrpcTest, self).setUp()
    self.service = "swarming.v2.Bots"
    routes = handlers_prpc.get_routes() + handlers_bot.get_routes()
    self.app = webtest.TestApp(
        webapp2.WSGIApplication(routes, debug=True),
        extra_environ={
          'REMOTE_ADDR': self.source_ip,
          'SERVER_SOFTWARE': os.environ['SERVER_SOFTWARE'],
        },
    )
    self._headers = {
      'Content-Type': encoding.Encoding.JSON[1],
      'Accept': encoding.Encoding.JSON[1],
    }
    self.now = datetime.datetime(2010, 1, 2, 3, 4, 5)
    self.mock_now(self.now)
    self.mock_default_pool_acl([])
    self.mock_tq_tasks()

  def test_bot_get(self):
    self.set_as_bot()
    self.do_handshake()
    self.set_as_privileged_user()
    request = swarming_pb2.BotRequest(bot_id="bot1", )
    resp = self.post_prpc("GetBot", request)
    actual_info = swarming_pb2.BotInfo()
    _decode(resp.body, actual_info)
    expected = message_conversion_prpc.bot_info_to_proto(
        bot_management.get_info_key('bot1').get())
    self.assertEqual(expected, actual_info)

  def test_bot_in_maintenance(self):
    self.set_as_privileged_user()
    _bot_event('request_sleep', 'bot1', maintenance_msg='boiling water')
    request = swarming_pb2.BotRequest(bot_id="bot1", )
    resp = self.post_prpc("GetBot", request)
    actual_info = swarming_pb2.BotInfo()
    _decode(resp.body, actual_info)
    expected = message_conversion_prpc.bot_info_to_proto(
        bot_management.get_info_key('bot1').get())
    self.assertTrue(actual_info.maintenance_msg)
    self.assertEqual(expected, actual_info)

  def test_bot_get_not_found(self):
    self.set_as_privileged_user()
    request = swarming_pb2.BotRequest(bot_id="bot1", )
    resp = self.post_prpc("GetBot", request, expect_errors=True)
    self.assertEqual(resp.status, '404 Not Found')
    self.assertEqual(resp.body, 'bot1 not found.')

  def test_get_deleted_bot(self):
    bot_id = "bot1"
    _bot_event('bot_connected', bot_id=bot_id, state={'foo': 0})
    self.set_as_admin()
    request = swarming_pb2.BotRequest(bot_id=bot_id, )
    resp = self.post_prpc("DeleteBot", request)
    expected = swarming_pb2.DeleteResponse(deleted=True)
    actual = swarming_pb2.DeleteResponse(deleted=True)
    _decode(resp.body, actual)
    self.assertEqual(expected, actual)

    # Now check whether the bot still exists, it will return not found
    request = swarming_pb2.BotRequest(bot_id=bot_id, )
    resp = self.post_prpc("GetBot", request)
    self.assertEqual(resp.status, '200 OK')
    ghost_bot = swarming_pb2.BotInfo()
    _decode(resp.body, ghost_bot)
    self.assertTrue(ghost_bot.deleted)

  def test_unauthorized_bot_not_found(self):
    self.set_as_anonymous()
    request = swarming_pb2.BotRequest(bot_id="bot1", )
    resp = self.post_prpc("GetBot", request, expect_errors=True)
    self.assertEqual(resp.status, '403 Forbidden')
    self.assertEqual(resp.body, 'Access is denied.')

  @parameterized.expand([
      'GetBot',
      'ListBotEvents',
  ])
  def test_get_ok_realm(self, api):
    # non-privileged user with realm permission.
    self.mock_auth_db([auth.Permission('swarming.pools.listBots')])
    self.set_as_user()

    _bot_event('bot_connected', bot_id='id1')
    resp = self.post_prpc(api,
                          swarming_pb2.BotRequest(bot_id='id1'),
                          expect_errors=True)
    self.assertEqual(resp.status, '403 Forbidden')

  @parameterized.expand([
      'GetBot',
      'ListBotEvents',
  ])
  def test_get_forbidden(self, api):
    self.mock_auth_db([])

    # non-privileged user with no realm permission.
    self.set_as_user()

    # alive bot
    _bot_event('bot_connected', bot_id='id1')
    resp = self.post_prpc(api,
                          swarming_pb2.BotRequest(bot_id='id1'),
                          expect_errors=True)
    self.assertEqual(resp.status, '403 Forbidden')

    # deleted bot
    with mock.patch('server.acl._is_admin', return_value=True):
      self.post_prpc('DeleteBot', swarming_pb2.BotRequest(bot_id='id1'))
    resp = self.post_prpc(api,
                          swarming_pb2.BotRequest(bot_id='id1'),
                          expect_errors=True)
    self.assertEqual(resp.status, '403 Forbidden')

  def test_delete_ok(self):
    """Assert that delete finds and deletes a bot."""
    self.set_as_admin()
    self.mock(acl, '_is_admin', lambda *_args, **_kwargs: True)
    state = {
        'dict': {
            'random': 'values'
        },
        'float': 0.,
        'list': ['of', 'things'],
        'str': u'uni',
    }
    _bot_event('request_sleep', bot_id='id1', state=state)

    # delete the bot
    resp = self.post_prpc('DeleteBot', swarming_pb2.BotRequest(bot_id='id1'))
    actual = swarming_pb2.DeleteResponse()
    _decode(resp.body, actual)
    self.assertEqual(swarming_pb2.DeleteResponse(deleted=True), actual)

    # is it gone?
    resp = self.post_prpc('DeleteBot',
                          swarming_pb2.BotRequest(bot_id='id1'),
                          expect_errors=True)
    self.assertEqual(resp.status, '404 Not Found')

  def test_events(self):
    # Run one task, push an event manually.
    second = datetime.timedelta(seconds=1)
    self.mock(random, 'getrandbits', lambda _: 0x88)
    first_ticker = test_case.Ticker(self.now, datetime.timedelta(seconds=1))
    t1 = self.mock_now(first_ticker())

    self.set_as_bot()
    params = self.do_handshake()
    t2 = self.mock_now(first_ticker())

    self.bot_poll(params=params)
    self.set_as_user()
    self.client_create_task_raw()
    self.set_as_bot()
    t3 = self.mock_now(first_ticker())

    res = self.bot_poll(params=params)
    now_60 = first_ticker.last() + datetime.timedelta(seconds=60)
    second_ticker = test_case.Ticker(now_60, datetime.timedelta(seconds=1))
    t4 = self.mock_now(second_ticker())

    resp = self.bot_complete_task(task_id=res['manifest']['task_id'])
    self.assertEqual({u'must_stop': False, u'ok': True}, resp)
    params['event'] = 'bot_rebooting'
    params['message'] = 'for the best'
    t5 = self.mock_now(second_ticker())

    resp = self.post_json('/swarming/api/v1/bot/event', params)
    self.assertEqual({}, resp)
    start = first_ticker.first()
    end = second_ticker.last()
    self.set_as_privileged_user()
    request = swarming_pb2.BotEventsRequest(bot_id="bot1", limit=200)
    request.start.FromDatetime(start)
    request.end.FromDatetime(end + second)
    resp = self.post_prpc("ListBotEvents", request)
    dimensions = [
        {
            u'key': u'id',
            u'value': [u'bot1']
        },
        {
            u'key': u'os',
            u'value': [u'Amiga']
        },
        {
            u'key': u'pool',
            u'value': [u'default']
        },
    ]
    state_dict = {
        'bot_group_cfg_version': 'default',
        'running_time': 1234.,
        'sleep_streak': 0,
        'started_ts': 1410990411.111,
    }
    state = unicode(
        json.dumps(state_dict, sort_keys=True, separators=(',', ':')))
    state_dict.pop('bot_group_cfg_version')
    state_no_cfg_ver = unicode(
        json.dumps(state_dict, sort_keys=True, separators=(',', ':')))
    items = [
        {
            u'authenticated_as': u'bot:whitelisted-ip',
            u'dimensions': dimensions,
            u'event_type': u'bot_rebooting',
            u'external_ip': unicode(self.source_ip),
            u'message': u'for the best',
            u'quarantined': False,
            u'state': state,
            u'ts': fmtdate(t5),
            u'version': unicode(self.bot_version),
        },
        {
            u'authenticated_as': u'bot:whitelisted-ip',
            u'dimensions': dimensions,
            u'event_type': u'task_completed',
            u'external_ip': unicode(self.source_ip),
            u'quarantined': False,
            u'state': state,
            u'task_id': res['manifest']['task_id'],
            u'ts': fmtdate(t4),
            u'version': unicode(self.bot_version),
        },
        {
            u'authenticated_as': u'bot:whitelisted-ip',
            u'dimensions': dimensions,
            u'event_type': u'request_task',
            u'external_ip': unicode(self.source_ip),
            u'quarantined': False,
            u'state': state,
            u'task_id': res['manifest']['task_id'],
            u'ts': fmtdate(t3),
            u'version': unicode(self.bot_version),
        },
        {
            u'authenticated_as': u'bot:whitelisted-ip',
            u'dimensions': dimensions,
            u'event_type': u'request_sleep',
            u'external_ip': unicode(self.source_ip),
            u'quarantined': False,
            u'state': state,
            u'ts': fmtdate(t2),
            u'version': unicode(self.bot_version),
        },
        {
            u'authenticated_as': u'bot:whitelisted-ip',
            u'dimensions': dimensions,
            u'event_type': u'bot_connected',
            u'external_ip': unicode(self.source_ip),
            u'quarantined': False,
            u'state': state_no_cfg_ver,
            u'ts': fmtdate(t1),
            u'version': u'123',
        },
    ]
    expected = swarming_pb2.BotEventsResponse()
    _decode_dict(dict(items=items), expected)
    actual = swarming_pb2.BotEventsResponse()
    _decode(resp.body, actual)

    # Now test with a subset.
    start = second_ticker.first()
    end = second_ticker.last()
    request = swarming_pb2.BotEventsRequest(bot_id="bot1", limit=200)
    request.start.FromDatetime(start)
    request.end.FromDatetime(end + second)
    _encode(request)
    resp = self.post_prpc("ListBotEvents", request)
    actual = swarming_pb2.BotEventsResponse()
    _decode(resp.body, actual)

    # actual.items[:] converts to a list so it can be compared with expected
    # items
    self.assertEqual(expected.items[:2], actual.items[:])

  def test_terminate_admin(self):
    self.set_as_bot()
    self.bot_poll()
    self.mock(random, 'getrandbits', lambda _: 0x88)

    self.set_as_admin()
    request = swarming_pb2.BotRequest(bot_id="bot1")
    resp = self.post_prpc('TerminateBot', request)
    actual = swarming_pb2.TerminateResponse()
    _decode(resp.body, actual)
    expected = swarming_pb2.TerminateResponse(task_id='5cee488008810')
    self.assertEqual(expected, actual)

  def test_terminate_privileged_user(self):
    self.set_as_bot()
    self.bot_poll()
    self.mock(random, 'getrandbits', lambda _: 0x88)

    self.set_as_privileged_user()
    request = swarming_pb2.BotRequest(bot_id="bot1")
    resp = self.post_prpc('TerminateBot', request)
    actual = swarming_pb2.TerminateResponse()
    _decode(resp.body, actual)
    expected = swarming_pb2.TerminateResponse(task_id='5cee488008810')
    self.assertEqual(expected, actual)

  def test_terminate_user(self):
    self.set_as_bot()
    self.bot_poll()
    self.mock(random, 'getrandbits', lambda _: 0x88)

    # without realm permission.
    self.set_as_user()
    self.mock_auth_db([])
    request = swarming_pb2.BotRequest(bot_id="bot1")
    resp = self.post_prpc('TerminateBot', request, expect_errors=True)
    expected = cgi.escape(
        'user "user@example.com" does not have '
        'permission "swarming.pools.terminateBot"',
        quote=True)
    self.assertEqual(expected, resp.body)

    # give permission.
    self.mock_auth_db([auth.Permission('swarming.pools.terminateBot')])
    request = swarming_pb2.BotRequest(bot_id="bot1")
    resp = self.post_prpc('TerminateBot', request)
    actual = swarming_pb2.TerminateResponse()
    _decode(resp.body, actual)
    expected = swarming_pb2.TerminateResponse(task_id='5cee488008810')
    self.assertEqual(expected, actual)

  def test_tasks_ok(self):
    """Asserts that tasks produces bot information."""
    self.mock(random, 'getrandbits', lambda _: 0x88)

    self.set_as_bot()
    self.bot_poll()
    self.set_as_user()
    self.client_create_task_raw()
    self.set_as_bot()
    res = self.bot_poll()
    response = self.bot_complete_task(task_id=res['manifest']['task_id'])
    self.assertEqual({u'must_stop': False, u'ok': True}, response)

    now_1 = self.mock_now(self.now, 1)
    self.mock(random, 'getrandbits', lambda _: 0x55)
    self.set_as_user()
    self.client_create_task_raw(name='philbert')
    self.set_as_bot()
    res = self.bot_poll()
    response = self.bot_complete_task(exit_code=1,
                                      task_id=res['manifest']['task_id'])
    self.assertEqual({u'must_stop': False, u'ok': True}, response)

    start = self.now + datetime.timedelta(seconds=0.5)
    end = now_1 + datetime.timedelta(seconds=0.5)

    self.set_as_privileged_user()
    request = swarming_pb2.BotTasksRequest()
    request.bot_id = 'bot1'
    request.start.FromDatetime(start)
    request.end.FromDatetime(end)
    request.sort = swarming_pb2.QUERY_CREATED_TS
    request.state = swarming_pb2.QUERY_ALL
    request.include_performance_stats = True
    request.limit = 100
    response = self.post_prpc('ListBotTasks', request)
    actual = swarming_pb2.TaskListResponse()
    _decode(response.body, actual)

    expected = swarming_pb2.TaskResultResponse()
    self.apply_defaults_for_run_result(expected)
    expected.bot_idle_since_ts.FromDatetime(now_1)
    expected.completed_ts.FromDatetime(now_1)
    expected.modified_ts.FromDatetime(now_1)
    expected.started_ts.FromDatetime(now_1)
    expected.created_ts.FromDatetime(now_1)
    expected.duration = 0.1
    expected.name = 'philbert'
    expected.exit_code = 1
    expected.failure = True
    expected.run_id = '5cee870005511'
    expected.state = swarming_pb2.TaskState.COMPLETED
    expected.task_id = '5cee870005511'
    expected.costs_usd[:] = [0.1]
    self.gen_perf_stats_prpc(expected.performance_stats)
    self.assertEqual(expected, actual.items[0])

  def test_all_task_sorts(self):
    self.set_as_privileged_user()
    for sort in (swarming_pb2.QUERY_CREATED_TS, swarming_pb2.QUERY_STARTED_TS,
                 swarming_pb2.QUERY_COMPLETED_TS):
      request = swarming_pb2.BotTasksRequest()
      request.bot_id = 'bot1'
      request.sort = sort
      request.state = swarming_pb2.QUERY_ALL
      request.include_performance_stats = True
      request.limit = 100
      response = self.post_prpc('ListBotTasks', request)
      self.assertEqual(response.status, '200 OK')

  def test_abandoned_has_error(self):
    """abandoned_ts does not have an index with bot_id. So we test that it
    specifically will return a 400 bad request.
    """
    self.set_as_privileged_user()
    request = swarming_pb2.BotTasksRequest()
    request.bot_id = 'bot1'
    request.sort = swarming_pb2.QUERY_ABANDONED_TS
    request.state = swarming_pb2.QUERY_ALL
    request.include_performance_stats = True
    request.limit = 100
    response = self.post_prpc('ListBotTasks', request, expect_errors=True)
    self.assertEqual(response.status, '400 Bad Request')

  def test_all_task_state_filters(self):
    self.set_as_privileged_user()
    for state in swarming_pb2.StateQuery.DESCRIPTOR.values_by_number.keys():
      # state cannot be pending since it is a disallowed state for
      # a TaskRunResult. See task_result._validate_state_not_pending
      if state not in (swarming_pb2.QUERY_PENDING,
                       swarming_pb2.QUERY_PENDING_RUNNING,
                       swarming_pb2.QUERY_DEDUPED):
        request = swarming_pb2.BotTasksRequest()
        request.bot_id = 'bot1'
        request.state = state
        request.include_performance_stats = True
        request.limit = 100
        response = self.post_prpc('ListBotTasks', request)
        self.assertEqual(response.status, '200 OK')

  def test_all_task_state_filters_disallowed_states(self):
    self.set_as_privileged_user()
    # State cannot be any of these states, since for `bot.list_tasks`
    # a TaskRunResult. See task_result._DISALLOWED_STATES
    for state in (swarming_pb2.QUERY_PENDING,
                  swarming_pb2.QUERY_PENDING_RUNNING,
                  swarming_pb2.QUERY_DEDUPED):
      request = swarming_pb2.BotTasksRequest()
      request.bot_id = 'bot1'
      request.state = state
      request.include_performance_stats = True
      request.limit = 100
      response = self.post_prpc('ListBotTasks', request, expect_errors=True)
      self.assertEqual(response.status, '400 Bad Request')


class TaskServicePrpcTest(PrpcTest):
  def setUp(self):
    super(TaskServicePrpcTest, self).setUp()
    self.service = "swarming.v2.Tasks"
    routes = handlers_prpc.get_routes() + handlers_bot.get_routes()
    self.app = webtest.TestApp(
        webapp2.WSGIApplication(routes, debug=True),
        extra_environ={
            'REMOTE_ADDR': self.source_ip,
            'SERVER_SOFTWARE': os.environ['SERVER_SOFTWARE'],
        },
    )
    self._headers = {
        'Content-Type': encoding.Encoding.JSON[1],
        'Accept': encoding.Encoding.JSON[1],
    }
    self.now = datetime.datetime(2010, 1, 2, 3, 4, 5)
    self.mock_now(self.now)
    self.mock_default_pool_acl([])
    self.mock_tq_tasks()
    self.mock(service_accounts, 'has_token_server', lambda: True)

  def test_result_unknown(self):
    """Asserts that result raises 404 for unknown task IDs."""
    self.set_as_privileged_user()
    resp = self.post_prpc('GetResult',
                          swarming_pb2.TaskIdWithPerfRequest(task_id='12310'),
                          expect_errors=True)
    self.assertEqual(resp.status, '404 Not Found')

  def test_result_long(self):
    """Asserts that result raises 400 for wildly invalid task IDs."""
    self.set_as_privileged_user()
    resp = self.post_prpc('GetResult',
                          swarming_pb2.TaskIdWithPerfRequest(task_id='12310' *
                                                             10),
                          expect_errors=True)
    self.assertEqual(resp.status, '400 Bad Request')

  def test_result_ok(self):
    """Asserts that result produces a result entity."""
    self.mock(random, 'getrandbits', lambda _: 0x88)
    self.set_as_bot()
    self.bot_poll()

    # pending task
    self.set_as_user()
    _, task_id = self.client_create_task_raw()
    response = self.post_prpc(
        'GetResult', swarming_pb2.TaskIdWithPerfRequest(task_id=task_id))
    expected = swarming_pb2.TaskResultResponse()
    expected.created_ts.FromDatetime(self.now)
    expected.modified_ts.FromDatetime(self.now)
    expected.failure = False
    expected.internal_failure = False
    expected.name = 'job1'
    expected.server_versions[:] = ['v1a']
    expected.state = swarming_pb2.TaskState.PENDING
    expected.tags[:] = [
        u'a:tag',
        u'authenticated:user:user@example.com',
        u'os:Amiga',
        u'pool:default',
        u'priority:20',
        u'realm:none',
        u'service_account:none',
        u'swarming.pool.template:none',
        u'swarming.pool.version:pools_cfg_rev',
        u'user:joe@localhost',
    ]
    expected.task_id = '5cee488008810'
    expected.user = 'joe@localhost'

    actual = swarming_pb2.TaskResultResponse()
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

    # no bot started: running task
    run_id = task_id[:-1] + '1'
    response = self.post_prpc(
        'GetResult',
        swarming_pb2.TaskIdWithPerfRequest(task_id=run_id),
        expect_errors=True)
    self.assertEqual(response.status, '404 Not Found')

    # run as bot
    self.set_as_bot()
    self.bot_poll()

    self.set_as_user()
    response = self.post_prpc(
        'GetResult', swarming_pb2.TaskIdWithPerfRequest(task_id=run_id))
    expected = swarming_pb2.TaskResultResponse()
    self.apply_defaults_for_run_result(expected)
    expected.bot_idle_since_ts.FromDatetime(self.now)
    expected.created_ts.FromDatetime(self.now)
    expected.modified_ts.FromDatetime(self.now)
    expected.started_ts.FromDatetime(self.now)
    expected.current_task_slice = 0
    actual = swarming_pb2.TaskResultResponse()
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

  def test_result_completed_task(self):
    """Tests that completed tasks are correctly reported."""
    self.set_as_bot()
    self.bot_poll()
    self.set_as_user()
    self.client_create_task_raw()
    self.set_as_bot()
    task_id = self.bot_run_task()
    # First ask without perf metadata.
    self.set_as_user()
    response = self.post_prpc(
        'GetResult',
        swarming_pb2.TaskIdWithPerfRequest(task_id=task_id,
                                           include_performance_stats=True))

    expected = swarming_pb2.TaskResultResponse()
    self.apply_defaults_for_run_result(expected)
    self.gen_perf_stats_prpc(expected.performance_stats)
    expected.bot_idle_since_ts.FromDatetime(self.now)
    expected.completed_ts.FromDatetime(self.now)
    expected.modified_ts.FromDatetime(self.now)
    expected.created_ts.FromDatetime(self.now)
    expected.started_ts.FromDatetime(self.now)
    expected.state = swarming_pb2.COMPLETED
    expected.costs_usd[:] = [0.1]
    expected.run_id = task_id
    expected.task_id = task_id
    expected.duration = 0.1
    actual = swarming_pb2.TaskResultResponse()
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

  def test_request_unknown(self):
    """Asserts that 404 is raised for unknown tasks."""
    self.set_as_user()
    response = self.post_prpc('GetRequest',
                              swarming_pb2.TaskIdRequest(task_id='12310'),
                              expect_errors=True)
    self.assertEqual(response.status, '404 Not Found')

  def test_request_ok(self):
    """Asserts that request produces a task request."""
    self.set_as_user()
    self.mock(random, 'getrandbits', lambda _: 0x88)
    self.mock_default_pool_acl(['service-account@example.com'])
    self.mock_auth_db([
        auth.Permission('swarming.pools.createTask'),
        auth.Permission('swarming.tasks.createInRealm'),
    ])

    _, task_id = self.client_create_task_raw(
        properties={'secret_bytes': 'zekret'},
        service_account='service-account@example.com',
        realm='test:task_realm')

    expected_props = swarming_pb2.TaskProperties()
    apply_default_for_task_props(expected_props)
    expected_props.secret_bytes = b'<REDACTED>'
    expected_props.command[:] = ['python', 'run_test.py']
    expected = swarming_pb2.TaskRequestResponse(
        properties=expected_props,
        task_slices=[
            swarming_pb2.TaskSlice(expiration_secs=86400,
                                   properties=expected_props,
                                   wait_for_capacity=False)
        ])
    apply_defaults_for_request(expected)
    expected.created_ts.FromDatetime(self.now)
    expected.service_account = 'service-account@example.com'
    expected.bot_ping_tolerance_secs = 600
    expected.expiration_secs = 86400
    expected.realm = 'test:task_realm'
    expected.tags[:] = [
        u'a:tag',
        u'authenticated:user:user@example.com',
        u'os:Amiga',
        u'pool:default',
        u'priority:20',
        u'realm:test:task_realm',
        u'service_account:service-account@example.com',
        u'swarming.pool.template:none',
        u'swarming.pool.version:pools_cfg_rev',
        u'user:joe@localhost',
    ]
    response = self.post_prpc('GetRequest',
                              swarming_pb2.TaskIdRequest(task_id=task_id))
    actual = swarming_pb2.TaskRequestResponse()
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

  def test_cancel_pending(self):
    """Asserts that task cancellation goes smoothly."""
    # catch PubSub notification
    # Create and cancel a task as a non-privileged user.
    self.mock(random, 'getrandbits', lambda _: 0x88)
    self.set_as_bot()
    self.bot_poll()
    self.set_as_user()
    _, task_id = self.client_create_task_raw(
        pubsub_topic='projects/abc/topics/def', pubsub_userdata='blah')
    expected = swarming_pb2.CancelResponse(canceled=True, was_running=False)
    response = self.post_prpc(
        'CancelTask',
        swarming_pb2.TaskCancelRequest(task_id=task_id, kill_running=False))
    actual = swarming_pb2.CancelResponse()
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

    # determine that the task's state updates correctly
    expected = swarming_pb2.TaskResultResponse(
        abandoned_ts=message_conversion_prpc.date(self.now),
        completed_ts=message_conversion_prpc.date(self.now),
        created_ts=message_conversion_prpc.date(self.now),
        current_task_slice=0,
        failure=False,
        internal_failure=False,
        modified_ts=message_conversion_prpc.date(self.now),
        name='job1',
        server_versions=['v1a'],
        state='CANCELED',
        tags=[
            'a:tag',
            'authenticated:user:user@example.com',
            'os:Amiga',
            'pool:default',
            'priority:20',
            'realm:none',
            'service_account:none',
            'swarming.pool.template:none',
            'swarming.pool.version:pools_cfg_rev',
            'user:joe@localhost',
        ],
        task_id=task_id,
        user=u'joe@localhost',
    )
    response = self.post_prpc(
        'GetResult',
        swarming_pb2.TaskIdWithPerfRequest(task_id=task_id,
                                           include_performance_stats=False))
    actual = swarming_pb2.TaskResultResponse()
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

  def test_cancel_forbidden(self):
    """Asserts that non-privileged non-owner can't cancel tasks."""
    # Create a task as an admin.
    self.mock(random, 'getrandbits', lambda _: 0x88)
    self.set_as_admin()
    _, task_id = self.client_create_task_raw(
        pubsub_topic='projects/abc/topics/def', pubsub_userdata='blah')

    # Attempt to cancel as non-privileged user -> HTTP 403.
    self.set_as_user()
    self.mock_auth_db([])
    response = self.post_prpc('CancelTask',
                              swarming_pb2.TaskCancelRequest(
                                  task_id=task_id, kill_running=False),
                              expect_errors=True)
    self.assertEqual(response.status, '403 Forbidden')

  def test_cancel_with_realm_permission(self):
    # someone creates tasks with/without realm.
    self.set_as_privileged_user()
    self.mock_auth_db([
        auth.Permission('swarming.pools.createTask'),
        auth.Permission('swarming.tasks.createInRealm'),
    ])
    _, task_id_with_realm = self.client_create_task_raw(realm='test:task_realm')
    _, task_id_without_realm = self.client_create_task_raw(realm=None)

    def assertTaskIsNotAccessible(task_id):
      response = self.post_prpc('CancelTask',
                                swarming_pb2.TaskCancelRequest(
                                    task_id=task_id, kill_running=False),
                                expect_errors=True)
      self.assertEqual(response.status, '403 Forbidden')
      self.assertEqual(
          cgi.escape('Task "%s" is not accessible' % task_id, quote=True),
          response.body)

    # non-privileged user can't cancel the both tasks without permission.
    self.set_as_user()
    assertTaskIsNotAccessible(task_id_with_realm)
    assertTaskIsNotAccessible(task_id_without_realm)

    # the user can cancel to the both tasks with swarming.pools.cancelTask
    # permission.
    self.mock_auth_db([auth.Permission('swarming.pools.cancelTask')])
    self.post_prpc(
        'CancelTask',
        swarming_pb2.TaskCancelRequest(task_id=task_id_with_realm,
                                       kill_running=False))
    self.post_prpc(
        'CancelTask',
        swarming_pb2.TaskCancelRequest(task_id=task_id_without_realm,
                                       kill_running=False))
    # the user can cancel with swarming.tasks.cancel permission.
    self.mock_auth_db([auth.Permission('swarming.tasks.cancel')])
    self.post_prpc(
        'CancelTask',
        swarming_pb2.TaskCancelRequest(task_id=task_id_with_realm,
                                       kill_running=False))
    # but, not accessible to the task without realm.
    assertTaskIsNotAccessible(task_id_without_realm)

  def test_cancel_running(self):
    self.mock(random, 'getrandbits', lambda _: 0x88)
    self.set_as_bot()
    self.bot_poll()
    self.set_as_user()
    _, task_id = self.client_create_task_raw(properties=dict(
        command=['python', 'runtest.py']))

    self.set_as_bot()
    params = self.do_handshake()
    data = self.post_json('/swarming/api/v1/bot/poll', params)
    run_id = data['manifest']['task_id']

    def _params(**kwargs):
      out = {
          'cost_usd': 0.1,
          'duration': None,
          'exit_code': None,
          'id': 'bot1',
          'output': None,
          'output_chunk_start': 0,
          'task_id': run_id,
      }
      out.update(**kwargs)
      return out

    self.set_as_bot()
    params = _params(output=base64.b64encode('Oh '))
    response = self.post_json('/swarming/api/v1/bot/task_update', params)
    self.assertEqual({u'must_stop': False, u'ok': True}, response)
    self.set_as_user()
    expected = swarming_pb2.TaskResultResponse()
    self.apply_defaults_for_result_summary(expected)
    expected.bot_idle_since_ts.FromDatetime(self.now)
    expected.costs_usd[:] = [0.1]
    expected.created_ts.FromDatetime(self.now)
    expected.modified_ts.FromDatetime(self.now)
    expected.started_ts.FromDatetime(self.now)
    expected.state = swarming_pb2.TaskState.RUNNING
    expected.tags[:] = [
        u'a:tag', u'authenticated:user:user@example.com', u'os:Amiga',
        u'pool:default', u'priority:20', u'realm:none', u'service_account:none',
        u'swarming.pool.template:none', u'swarming.pool.version:pools_cfg_rev',
        u'user:joe@localhost'
    ]
    actual = swarming_pb2.TaskResultResponse()
    response = self.post_prpc(
        'GetResult',
        swarming_pb2.TaskIdWithPerfRequest(task_id=task_id,
                                           include_performance_stats=False))
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

    # Denied if kill_running == False.
    response = self.post_prpc('CancelTask',
                              swarming_pb2.TaskCancelRequest(
                                  task_id=task_id, kill_running=False),
                              expect_errors=True)
    actual = swarming_pb2.CancelResponse()
    _decode(response.body, actual)
    self.assertEqual(
        swarming_pb2.CancelResponse(canceled=False, was_running=True), actual)

    # Works if kill_running == True.
    response = self.post_prpc('CancelTask',
                              swarming_pb2.TaskCancelRequest(task_id=task_id,
                                                             kill_running=True),
                              expect_errors=True)
    actual = swarming_pb2.CancelResponse()
    _decode(response.body, actual)
    self.assertEqual(
        swarming_pb2.CancelResponse(canceled=True, was_running=True), actual)

    self.set_as_bot()
    params = _params(output=base64.b64encode('hi'), output_chunk_start=3)
    response = self.post_json('/swarming/api/v1/bot/task_update', params)
    self.assertEqual({u'must_stop': True, u'ok': True}, response)

    # abandoned_ts is set but state isn't changed yet.
    self.set_as_user()
    expected = swarming_pb2.TaskResultResponse()
    self.apply_defaults_for_result_summary(expected)
    expected.abandoned_ts.FromDatetime(self.now)
    expected.bot_idle_since_ts.FromDatetime(self.now)
    expected.costs_usd[:] = [0.1]
    expected.created_ts.FromDatetime(self.now)
    expected.modified_ts.FromDatetime(self.now)
    expected.started_ts.FromDatetime(self.now)
    expected.state = swarming_pb2.TaskState.RUNNING
    expected.tags[:] = [
        'a:tag',
        'authenticated:user:user@example.com',
        'os:Amiga',
        'pool:default',
        'priority:20',
        'realm:none',
        'service_account:none',
        'swarming.pool.template:none',
        'swarming.pool.version:pools_cfg_rev',
        'user:joe@localhost',
    ]
    actual = swarming_pb2.TaskResultResponse()
    response = self.post_prpc(
        'GetResult',
        swarming_pb2.TaskIdWithPerfRequest(task_id=task_id,
                                           include_performance_stats=False))
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

    # Bot terminates the task.
    self.set_as_bot()
    params = _params(output=base64.b64encode(' again'),
                     output_chunk_start=6,
                     duration=0.1,
                     exit_code=0)
    response = self.post_json('/swarming/api/v1/bot/task_update', params)
    self.assertEqual({u'must_stop': True, u'ok': True}, response)

    self.set_as_user()
    expected = swarming_pb2.TaskResultResponse()
    self.apply_defaults_for_result_summary(expected)
    expected.abandoned_ts.FromDatetime(self.now)
    expected.bot_idle_since_ts.FromDatetime(self.now)
    expected.completed_ts.FromDatetime(self.now)
    expected.costs_usd[:] = [0.1]
    expected.created_ts.FromDatetime(self.now)
    expected.duration = 0.1
    expected.exit_code = 0
    expected.modified_ts.FromDatetime(self.now)
    expected.started_ts.FromDatetime(self.now)
    expected.state = swarming_pb2.TaskState.KILLED
    expected.tags[:] = [
        u'a:tag',
        u'authenticated:user:user@example.com',
        u'os:Amiga',
        u'pool:default',
        u'priority:20',
        u'realm:none',
        u'service_account:none',
        u'swarming.pool.template:none',
        u'swarming.pool.version:pools_cfg_rev',
        u'user:joe@localhost',
    ]
    actual = swarming_pb2.TaskResultResponse()
    response = self.post_prpc(
        'GetResult',
        swarming_pb2.TaskIdWithPerfRequest(task_id=task_id,
                                           include_performance_stats=False))
    _decode(response.body, actual)
    self.assertEqual(expected, actual)

  def test_stdout_ok(self):
    """Asserts that stdout reports a task's output."""
    self.set_as_bot()
    self.bot_poll()
    self.set_as_user()
    self.client_create_task_raw()

    # task_id determined by bot run
    self.set_as_bot()
    task_id = self.bot_run_task()

    self.set_as_privileged_user()
    run_id = task_id[:-1] + '1'
    expected = swarming_pb2.TaskOutputResponse(
        output=u'rÉsult string', state=swarming_pb2.TaskState.COMPLETED)
    for i in (task_id, run_id):
      response = self.post_prpc('GetStdout',
                                swarming_pb2.TaskIdWithOffsetRequest(task_id=i))
      actual = swarming_pb2.TaskOutputResponse()
      _decode(response.body, actual)
      self.assertEqual(expected, actual)

    # Partial fetch.
    response = self.post_prpc(
        'GetStdout',
        swarming_pb2.TaskIdWithOffsetRequest(task_id=task_id,
                                             offset=1,
                                             length=2))
    actual = swarming_pb2.TaskOutputResponse()
    _decode(response.body, actual)
    # This is because it's counting in bytes, not in unicode characters:
    expected = swarming_pb2.TaskOutputResponse(
        output=u'É', state=swarming_pb2.TaskState.COMPLETED)
    self.assertEqual(expected, actual)

    response = self.post_prpc(
        'GetStdout',
        swarming_pb2.TaskIdWithOffsetRequest(task_id=task_id,
                                             offset=3,
                                             length=5))
    actual = swarming_pb2.TaskOutputResponse()
    _decode(response.body, actual)
    expected = swarming_pb2.TaskOutputResponse(
        output=u'sult ', state=swarming_pb2.TaskState.COMPLETED)
    self.assertEqual(expected, actual)

  def test_stdout_empty(self):
    """Asserts that incipient tasks produce no output."""
    self.set_as_user()
    _, task_id = self.client_create_task_raw()
    response = self.post_prpc(
        'GetStdout', swarming_pb2.TaskIdWithOffsetRequest(task_id=task_id))
    actual = swarming_pb2.TaskOutputResponse()
    _decode(response.body, actual)
    expected = swarming_pb2.TaskOutputResponse(
        state=swarming_pb2.TaskState.NO_RESOURCE)
    self.assertEqual(expected, actual)

  def test_result_run_not_found(self):
    self.set_as_user()
    _, task_id = self.client_create_task_raw()
    run_id = task_id[:-1] + '1'
    response = self.post_prpc(
        'GetStdout',
        swarming_pb2.TaskIdWithOffsetRequest(task_id=run_id),
        expect_errors=True)
    self.assertEqual(response.status, '404 Not Found')

  def test_task_deduped(self):
    """Asserts that task deduplication works as expected."""
    self.set_as_user()
    self.set_as_bot()
    self.bot_poll()
    self.set_as_user()
    _, task_id_1 = self.client_create_task_raw(properties=dict(idempotent=True))

    self.set_as_bot()
    task_id_bot = self.bot_run_task()
    self.assertEqual(task_id_1, task_id_bot[:-1] + '0')
    self.assertEqual('1', task_id_bot[-1:])

    # second task; this one's results should be returned immediately
    self.set_as_user()
    _, task_id_2 = self.client_create_task_raw(name='second',
                                               user='jack@localhost',
                                               properties=dict(idempotent=True))

    self.set_as_bot()
    resp = self.bot_poll()
    self.assertEqual('sleep', resp['cmd'])

    self.set_as_user()

    # results shouldn't change, even if the second task wasn't executed
    response = self.post_prpc(
        'GetStdout', swarming_pb2.TaskIdWithOffsetRequest(task_id=task_id_2))
    actual = swarming_pb2.TaskOutputResponse()
    _decode(response.body, actual)
    expected = swarming_pb2.TaskOutputResponse(
        output=u'rÉsult string', state=swarming_pb2.TaskState.COMPLETED)
    self.assertEqual(expected, actual)

  @parameterized.expand(['GetRequest', 'GetResult', 'GetStdout'])
  def test_get_with_realm_permission(self, api):
    # someone creates tasks with/without realm.
    self.set_as_privileged_user()
    self.mock_auth_db([
        auth.Permission('swarming.pools.createTask'),
        auth.Permission('swarming.tasks.createInRealm'),
    ])
    _, task_id_with_realm = self.client_create_task_raw(realm='test:task_realm')
    _, task_id_without_realm = self.client_create_task_raw(realm=None)

    def create_request(task_id):
      if api == 'GetRequest':
        return swarming_pb2.TaskIdRequest(task_id=task_id)
      if api == 'GetResult':
        return swarming_pb2.TaskIdWithPerfRequest(task_id=task_id)
      if api == 'GetStdout':
        return swarming_pb2.TaskIdWithOffsetRequest(task_id=task_id)
      raise Exception('Unknown api %s' % api)

    def assertTaskIsNotAccessible(task_id):
      request = create_request(task_id)
      response = self.post_prpc(api, request, expect_errors=True)
      self.assertEqual(
          cgi.escape('Task "%s" is not accessible' % task_id, quote=True),
          response.body)

    # non-privileged user can't access to the both tasks without permission.
    self.set_as_user()
    assertTaskIsNotAccessible(task_id_with_realm)
    assertTaskIsNotAccessible(task_id_without_realm)

    # the user can access to the both tasks with swarming.pools.listTasks
    # permission.
    self.mock_auth_db([auth.Permission('swarming.pools.listTasks')])
    self.post_prpc(api, create_request(task_id_with_realm))
    self.post_prpc(api, create_request(task_id_without_realm))

    # the user can access with swarming.tasks.get permission.
    self.mock_auth_db([auth.Permission('swarming.tasks.get')])
    self.post_prpc(api, create_request(task_id_with_realm))
    # but, not accessible to the task with no realm.
    assertTaskIsNotAccessible(task_id_without_realm)


if __name__ == '__main__':
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
    logging.basicConfig(level=logging.DEBUG)
  else:
    logging.basicConfig(level=logging.FATAL)
  unittest.main()
