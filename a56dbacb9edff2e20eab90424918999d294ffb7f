{
  "comments": [
    {
      "key": {
        "uuid": "c4451ff9_218b9b61",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 506,
      "author": {
        "id": 1000487
      },
      "writtenOn": "2018-03-21T14:20:57Z",
      "side": 1,
      "message": "two lines between file level symbols.",
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "187fc644_95ee72f2",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 506,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c4451ff9_218b9b61",
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e3d91706_451bee21",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 508,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T11:55:24Z",
      "side": 1,
      "message": "Should be link_tree (not linktree) to match coding style. I\u0027d also call this copy_tree myself, because the only linking we do is for hardlinks and we don\u0027t even guarantee that. In particular, we do end up copying (recreating) the directory structure.\n\nI also find the fact that we overwrite \"src\" and \"dst\" hard to follow as well. Maybe pass in src_dir and dst_dir, rather than overwrite the passed-in variable?\n\nNeeds a comment as well:\n\"\"\"Efficiently copies a file or directory from src_dir to dst_dir.\n\n`item` may be a file, directory, or a symlink to a file or directory. All symlinks are replaced with their targets, so the resulting directory structure in dst_dir will never have any symlinks.\n\nTo increase speed, copy_tree hardlinks individual files into the (newly created) directory structure if possible, unlike Python\u0027s standard CopyTree function.\n\"\"\"",
      "range": {
        "startLine": 507,
        "startChar": 0,
        "endLine": 508,
        "endChar": 0
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28464755_b953b4a2",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 508,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T12:23:45Z",
      "side": 1,
      "message": "Also: is linktree/copy_tree supposed to prevent us from following symlinks outside the run_dir directory? I\u0027m ok to say \"no, don\u0027t prevent anything\" but I think Marc-Antoine wanted to be more careful.",
      "parentUuid": "e3d91706_451bee21",
      "range": {
        "startLine": 507,
        "startChar": 0,
        "endLine": 508,
        "endChar": 0
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c7109f2_f7849c41",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 508,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "Renamed the function. Sorry, it\u0027s been a while since I last touched LUCI code!\nRenamed the variables too.\nAdded the comment.\n\ncopy_tree doesn\u0027t currently prevent us from following symlinks outside the directory tree.\nIs it ok if I do that in a follow-up CL?",
      "parentUuid": "28464755_b953b4a2",
      "range": {
        "startLine": 507,
        "startChar": 0,
        "endLine": 508,
        "endChar": 0
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf0d4cd1_77f87638",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 509,
      "author": {
        "id": 1000487
      },
      "writtenOn": "2018-03-21T14:20:57Z",
      "side": 1,
      "message": "do this at the call site, not inside the function. There\u0027s no need to have \"item\" here.",
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "267eb6fb_c5f13c5c",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 509,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T14:25:48Z",
      "side": 1,
      "message": "I actually like it like this - otherwise you need to do it both internally (when traversing a subdir) and externally (when making the call).\n\nAlternative: def copy_tree(src_dir, dst_dir, item\u003dNone) and leave it up to the caller.",
      "parentUuid": "cf0d4cd1_77f87638",
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e443820_3732d323",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 509,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "Subdirs are the reason I wrote the function this way. I adapted Adrian\u0027s suggestion.",
      "parentUuid": "267eb6fb_c5f13c5c",
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c5c9ba5_c253f1a9",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 513,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T11:55:24Z",
      "side": 1,
      "message": "Does os.readlink recursively follow symlinks? If not, this needs to be:\n\nwhile fs.islink(src):\n  src \u003d os.readlink(src)\n\nAlso needs a comment: \"Replace symlinks with their target.\"",
      "range": {
        "startLine": 512,
        "startChar": 0,
        "endLine": 513,
        "endChar": 26
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34ba87e9_05e73b4e",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 513,
      "author": {
        "id": 1000487
      },
      "writtenOn": "2018-03-21T14:20:57Z",
      "side": 1,
      "message": "There\u0027s an example here: https://cs.chromium.org/chromium/infra/luci/client/isolated_format.py?l\u003d155",
      "parentUuid": "5c5c9ba5_c253f1a9",
      "range": {
        "startLine": 512,
        "startChar": 0,
        "endLine": 513,
        "endChar": 26
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa0f8678_f99aec3f",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 513,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T14:25:48Z",
      "side": 1,
      "message": "That example\u0027s a bit more complicated than we need, don\u0027t you think? It\u0027s trying to accurately preserve symlinks itself, whereas I don\u0027t think we\u0027re trying to do that - are we?",
      "parentUuid": "34ba87e9_05e73b4e",
      "range": {
        "startLine": 512,
        "startChar": 0,
        "endLine": 513,
        "endChar": 26
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70c29983_6fc96596",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 513,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "You mean there can be a symlink to a symlink? \nNo, os.readlink doesn\u0027t follow symlinks recursively. Done.",
      "parentUuid": "5c5c9ba5_c253f1a9",
      "range": {
        "startLine": 512,
        "startChar": 0,
        "endLine": 513,
        "endChar": 26
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "355d5aec_eb98141c",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 515,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T11:55:24Z",
      "side": 1,
      "message": "What happens if src is missing (eg broken symlink or just a missing file)? I\u0027d imagine that fs.isfile will be false, and we\u0027ll exit this function without any warnings or exceptions being thrown. Note that we *don\u0027t* necessarily want to throw an exception halfway through copying a tree, we probably want to copy as much of it as we can.",
      "range": {
        "startLine": 515,
        "startChar": 1,
        "endLine": 515,
        "endChar": 20
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b08ec7c_02ec3910",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 515,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T12:23:45Z",
      "side": 1,
      "message": "I partially take this back - there should be a way to know what files we expected to find but couldn\u0027t. Maybe throwing exceptions is the right way to track this? Note that if we identify the file that was missing, we should identify it using the names of the symlinks, not the resolved targets. So that might mean that before saying \u0027src \u003d os.readlink(src)\u0027, we make a copy called \u0027orig_src\u0027 or something like that.",
      "parentUuid": "355d5aec_eb98141c",
      "range": {
        "startLine": 515,
        "startChar": 1,
        "endLine": 515,
        "endChar": 20
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "87e7f024_b765a7f5",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 515,
      "author": {
        "id": 1000487
      },
      "writtenOn": "2018-03-21T14:20:57Z",
      "side": 1,
      "message": "I think it\u0027s fine to silently drop broken symlinks, as otherwise this could be a security issue if it permits to espace the isolated tree, but would work once mapped into the output tree. Unlikely but still, I prefer to reduce the attack surface.",
      "parentUuid": "4b08ec7c_02ec3910",
      "range": {
        "startLine": 515,
        "startChar": 1,
        "endLine": 515,
        "endChar": 20
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1927c0ea_82e2f02e",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 515,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T14:25:48Z",
      "side": 1,
      "message": "I mainly just want to log them, not return them to the user. But an exception is much easier to unit test than a log write.",
      "parentUuid": "87e7f024_b765a7f5",
      "range": {
        "startLine": 515,
        "startChar": 1,
        "endLine": 515,
        "endChar": 20
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "438ad072_fbf5e7d7",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 515,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "I went with logging. Will this work the way we want?",
      "parentUuid": "1927c0ea_82e2f02e",
      "range": {
        "startLine": 515,
        "startChar": 1,
        "endLine": 515,
        "endChar": 20
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2f02843_de949815",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 516,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T11:55:24Z",
      "side": 1,
      "message": "Needs a try-catch here IMO, with some logging if something goes wrong. Basically, copy_tree shouldn\u0027t throw, and link_outputs_to_outdir shouldn\u0027t have to catch.",
      "range": {
        "startLine": 516,
        "startChar": 0,
        "endLine": 516,
        "endChar": 67
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b1f41dc_3896c452",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 516,
      "author": {
        "id": 1000487
      },
      "writtenOn": "2018-03-21T14:20:57Z",
      "side": 1,
      "message": "Agreed, and it should try to go as far as possible, skipping (and logging) over failures.",
      "parentUuid": "e2f02843_de949815",
      "range": {
        "startLine": 516,
        "startChar": 0,
        "endLine": 516,
        "endChar": 67
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d909499_cc5de375",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 516,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e2f02843_de949815",
      "range": {
        "startLine": 516,
        "startChar": 0,
        "endLine": 516,
        "endChar": 67
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d57aa667_6cc246e2",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T11:55:24Z",
      "side": 1,
      "message": "This also overrides a passed-in variable. Maybe call this one \"child\" instead of \"item\"?",
      "range": {
        "startLine": 519,
        "startChar": 6,
        "endLine": 519,
        "endChar": 10
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b64bac0_8edf398e",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d57aa667_6cc246e2",
      "range": {
        "startLine": 519,
        "startChar": 6,
        "endLine": 519,
        "endChar": 10
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "25f03cd5_78b413fa",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 521,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T11:55:24Z",
      "side": 1,
      "message": "This should be moved outside of the loop - dst doesn\u0027t change on each iteration of the loop, so it\u0027s more clear to have it outside IMO.",
      "range": {
        "startLine": 520,
        "startChar": 0,
        "endLine": 521,
        "endChar": 19
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e960640_724309ba",
        "filename": "client/run_isolated.py",
        "patchSetId": 1
      },
      "lineNbr": 521,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "25f03cd5_78b413fa",
      "range": {
        "startLine": 520,
        "startChar": 0,
        "endLine": 521,
        "endChar": 19
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19577961_1c6b718a",
        "filename": "client/tests/run_isolated_test.py",
        "patchSetId": 1
      },
      "lineNbr": 925,
      "author": {
        "id": 1161612
      },
      "writtenOn": "2018-03-21T12:23:45Z",
      "side": 1,
      "message": "I don\u0027t think this is the right place to test all the different variants of copy_tree (or linktree). The \"script\" that gets run is no longer readable or paramaterizable, and it only is capable of testing a bunch of happy paths and none of the sad paths.\n\nI\u0027m thinking it would be better to have a class *just* to test copy_tree directly, allowing both happy and sad paths to be tested without having to go through the whole mocked flow. Eg, you should be able to specify something like this as a test input:\n\nsrc_dir \u003d {\n  \u0027foo_file\u0027: (FILE, \u0027contents of foo\u0027), #python tuple\n  \u0027bar_link\u0027: (LINK, \u0027foo_file\u0027),\n  \u0027bad_link\u0027: (LINK, \u0027nonexistent_file\u0027),\n  \u0027subdir_link\u0027: (LINK, \u0027sub_dir/child_a\u0027),\n  \u0027subdir\u0027:  (DIR, {\n    \u0027child_a\u0027: (FILE, \u0027contents of a\u0027),\n    \u0027child_b\u0027: (FILE, \u0027contents of b\u0027),\n  }),\n}\n\nAnd then verify that we have the following outputs:\nexpected \u003d {\n  \u0027/foo_file\u0027: \u0027contents of foo\u0027,\n  \u0027/bar_link\u0027: \u0027contents of foo\u0027,\n  \u0027/subdir_link\u0027: \u0027contents of a\u0027,\n  \u0027/subdir/child_a\u0027: \u0027contents of a\u0027,\n  \u0027/subdir/child_b\u0027: \u0027contents of b\u0027,\n}\nexpected_not_found \u003d [\u0027/bad_link\u0027]\n\nThis is much clearer than the existing test and lets you test far more complicated scenarios.",
      "range": {
        "startLine": 925,
        "startChar": 6,
        "endLine": 925,
        "endChar": 28
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4daa13d7_abda82ba",
        "filename": "client/tests/run_isolated_test.py",
        "patchSetId": 1
      },
      "lineNbr": 925,
      "author": {
        "id": 1245214
      },
      "writtenOn": "2018-03-22T16:55:39Z",
      "side": 1,
      "message": "I added the unit test.\nI also left one of the cases in the end-to-end test to be extra cautious!\nIs that ok?",
      "parentUuid": "19577961_1c6b718a",
      "range": {
        "startLine": 925,
        "startChar": 6,
        "endLine": 925,
        "endChar": 28
      },
      "revId": "a56dbacb9edff2e20eab90424918999d294ffb7f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}