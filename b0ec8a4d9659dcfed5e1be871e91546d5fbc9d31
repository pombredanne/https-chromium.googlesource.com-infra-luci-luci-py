{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "fb0142eb_2e34d923",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1547372
      },
      "writtenOn": "2022-09-19T18:44:11Z",
      "side": 1,
      "message": "Requesting review on second part of this CL. We need to deploy the first CL, and check whether it breaks anything before deploying this CL, which cannot be rolled back easily since it turns off monotonically decreasing sequences. ",
      "revId": "b0ec8a4d9659dcfed5e1be871e91546d5fbc9d31",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fb0d7bd_97b811aa",
        "filename": "appengine/swarming/server/bot_management.py",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1002539
      },
      "writtenOn": "2022-09-19T21:21:06Z",
      "side": 1,
      "message": "This is not necessary if BotRoot is never read.\n\nRoot entities don\u0027t need to physically exist in datastore in order to store child entities.\n\nUnfortunately, it is read in cron_delete_old_bot and in handlers_prpc :( But only its key matters.\n\nI think the best approach would be to do something like this:\n\n```\nentities \u003d [event, bot_info]\n\n# Non-transactional, hits ndb memcache almost always \u003d\u003e ~free.\nif not root_key.get():\n  entities.append(BotRoot(key\u003droot_key, ...))\n\ndef txn():\n  ndb.put_multi(entities)\n\n```\n\nHere we exploit the fact that it is OK to stomp over BotRoot if it already exists (because by the time we run the transaction, it may already exist). We also OK with a race when this code runs concurrently with cron_delete_old_bot (that may delete BotRoot): 1) this should never really happen, if a bot is sending events it is not old; 2) the next event would resurrect BotRoot.\n\nThe purpose of this is to avoid readings stuff in transaction, since it significantly increases chances of transaction collisions (of something else write to the entity group after we read it).",
      "range": {
        "startLine": 533,
        "startChar": 4,
        "endLine": 535,
        "endChar": 69
      },
      "revId": "b0ec8a4d9659dcfed5e1be871e91546d5fbc9d31",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c547033_0d851164",
        "filename": "appengine/swarming/server/bot_management.py",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1002539
      },
      "writtenOn": "2022-09-19T21:31:43Z",
      "side": 1,
      "message": "Oh, actually, at least in legacy datastore, it would also be totally fine to always unconditionally store BotRoot inside the transaction (since we are modifying the entity group anyway).\n\nI\u0027m less sure about how it works in new Firestore datastore.",
      "parentUuid": "5fb0d7bd_97b811aa",
      "range": {
        "startLine": 533,
        "startChar": 4,
        "endLine": 535,
        "endChar": 69
      },
      "revId": "b0ec8a4d9659dcfed5e1be871e91546d5fbc9d31",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35cf26f6_e03981cc",
        "filename": "appengine/swarming/server/bot_management.py",
        "patchSetId": 6
      },
      "lineNbr": 699,
      "author": {
        "id": 1002539
      },
      "writtenOn": "2022-09-19T21:21:06Z",
      "side": 1,
      "message": "Better to keep the exception uncaught and let it crash, because it will crash anyway, just with AttributeError (trying to look inside this None). Or even worse, it will store this None somewhere where an entity is expected.",
      "range": {
        "startLine": 699,
        "startChar": 2,
        "endLine": 699,
        "endChar": 13
      },
      "revId": "b0ec8a4d9659dcfed5e1be871e91546d5fbc9d31",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}